# -*- coding: utf-8 -*-
"""Copy of pairstradingday1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eCD9kyYZFCAczzc-WiAazQwnLbOxEoqi
"""

# engle_granger_pairs.py
# Requires: pip install yfinance pandas numpy statsmodels

from itertools import permutations
from typing import List, Tuple, Optional, Dict

import numpy as np
import pandas as pd
import yfinance as yf
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller

def download_prices(
    tickers: List[str],
    start: str = "2015-01-01",
    end: Optional[str] = None,
    price_field: Optional[str] = "Adj Close",  # try this first; fall back if missing
    log_prices: bool = True,
    align: str = "inner",                      # "inner" intersection or "outer" union
    auto_adjust: bool = False,                 # IMPORTANT: if True, no "Adj Close" in output
    group_by: str = "column",                  # yfinance default; we handle both layouts
) -> pd.DataFrame:
    """
    Download daily prices for many tickers and return a single DataFrame of levels
    with columns named by ticker. Handles yfinance's changing column layouts and
    missing 'Adj Close' by falling back to 'Close' transparently.
    """
    if isinstance(tickers, str):
        tickers = [tickers]

    raw = yf.download(
        tickers,
        start=start,
        end=end,
        progress=False,
        auto_adjust=auto_adjust,
        group_by=group_by,
        threads=True,
    )

    # Helper to pick the field that actually exists
    def choose_field(available_fields):
        # Honor explicit request if present
        if price_field is not None and price_field in available_fields:
            return price_field
        # If auto_adjust=True, 'Close' is the proper choice
        if auto_adjust and "Close" in available_fields:
            return "Close"
        # Fallback order
        for cand in ["Adj Close", "Close", "Price"]:
            if cand in available_fields:
                return cand
        # Last resort: take the first available field
        return available_fields[0]

    # Normalize to DataFrame with columns=tickers
    if isinstance(raw.columns, pd.MultiIndex):
        # Could be (field, ticker) or (ticker, field). Detect which level holds fields.
        level0, level1 = raw.columns.levels[0].tolist(), raw.columns.levels[1].tolist()

        # Heuristic: if 'Close' or 'Adj Close' is in level 0, layout is (field, ticker)
        if any(f in level0 for f in ("Adj Close", "Close", "Price")):
            field_level = 0
            ticker_level = 1
        else:
            field_level = 1
            ticker_level = 0

        fields_here = raw.columns.get_level_values(field_level).unique().tolist()
        chosen = choose_field(fields_here)

        # Slice out the chosen field across tickers
        data = raw.xs(chosen, axis=1, level=field_level)

        # Ensure only requested tickers (yfinance can reorder/drop)
        data = data[[c for c in data.columns if c in tickers]]
    else:
        # Single-level columns: either fields for a single ticker, or tickers for many
        cols = raw.columns.tolist()
        # Case A: looks like standard OHLCV fields for a *single* ticker
        if all(c in {"Open", "High", "Low", "Close", "Adj Close", "Volume"} for c in cols):
            chosen = choose_field(cols)
            data = raw[[chosen]].copy()
            # Name the column as the single ticker
            data.columns = [tickers[0]]
        else:
            # Case B: columns already are tickers (rare but possible)
            data = raw.copy()

    # Clean & align
    data = data.sort_index()
    data = data.dropna(how="all", axis=1)
    if align == "inner":
        data = data.dropna(how="any")

    if log_prices:
        data = np.log(data)

    if data.shape[1] == 0:
        raise ValueError(
            "No usable price columns found. "
            "Try setting price_field='Close' or auto_adjust=True, "
            "and verify the tickers actually have price history."
        )
    return data

def ols_hedge_ratio(y: pd.Series, x: pd.Series, include_const: bool = True) -> Tuple[float, float, np.ndarray]:
    """
    OLS regression: y_t = alpha + beta x_t + e_t
    Returns (alpha, beta, residuals).
    """
    if include_const:
        X = sm.add_constant(x.values, has_constant="add")
    else:
        X = x.values
    model = sm.OLS(y.values, X, missing="drop")
    res = model.fit()
    if include_const:
        alpha, beta = res.params[0], res.params[1]
        residuals = y.values - (alpha + beta * x.values)
    else:
        alpha, beta = 0.0, res.params[0]
        residuals = y.values - beta * x.values
    return alpha, beta, residuals

def adf_on_residuals(
    residuals: np.ndarray,
    regression: str = "c",  # "c" (constant), "ct" (constant+trend), "nc" (no constant)
    maxlag: Optional[int] = None,
    autolag: str = "AIC",
) -> Dict[str, object]:
    """
    ADF test of residuals from the OLS cointegrating regression (Engle–Granger step 2).
    Returns a dictionary of ADF outputs.
    """
    # Drop NaNs that can appear due to alignment issues
    res = pd.Series(residuals).dropna().values
    adf_stat, pval, usedlag, nobs, crit, icbest = adfuller(
        res, maxlag=maxlag, regression=regression, autolag=autolag
    )

    # Approximate AR(1) coefficient via OLS on Δe_t = phi*e_{t-1}+...
    # Then compute half-life = ln(2)/(-ln(1+phi)) (small-signal approx ≈ ln(2)/-phi if |phi|<<1).
    # More robustly, estimate phi from simple AR(1) on residuals level.
    e = pd.Series(res)
    e_lag = e.shift(1).dropna()
    e_cur = e.iloc[1:]
    phi = (np.cov(e_lag, e_cur, ddof=0)[0, 1]) / np.var(e_lag, ddof=0)
    # Guard for unstable phi
    if np.isfinite(phi) and -0.999 < phi < 0.999:
        half_life = np.log(2) / -np.log(max(1e-12, 1 + (phi - 1)))  # exact form
    else:
        half_life = np.nan

    return {
        "adf_stat": adf_stat,
        "pvalue": pval,
        "usedlag": usedlag,
        "nobs": nobs,
        "crit_1pct": crit.get("1%") if isinstance(crit, dict) else crit[0],
        "crit_5pct": crit.get("5%") if isinstance(crit, dict) else crit[1],
        "crit_10pct": crit.get("10%") if isinstance(crit, dict) else crit[2],
        "icbest": icbest,
        "phi_ar1": phi,
        "half_life": half_life,
    }

def engle_granger_pairs(
    tickers: List[str],
    start: str = "2015-01-01",
    end: Optional[str] = None,
    price_field: str = "Adj Close",
    log_prices: bool = True,
    include_const: bool = True,
    regression: str = "c",
    maxlag: Optional[int] = None,
    autolag: str = "AIC",
    pretest_unit_root: bool = False,
    drop_if_stationary_level: bool = True,
) -> pd.DataFrame:
    """
    For every ordered pair (Y|X), estimate OLS hedge ratio and run Engle–Granger ADF on residuals.
    Returns a DataFrame sorted by ADF statistic (more negative = stronger stationarity evidence).

    Parameters:
    - include_const: include intercept in cointegration regression. (Most common: True.)
    - regression: ADF regression type for residuals: "c", "ct", or "nc".
    - pretest_unit_root: if True, ADF test each *level* series and optionally drop level-stationary ones.
    - drop_if_stationary_level: if True and pretest finds a series level-stationary (I(0)),
      skip pairs involving that series (cointegration requires I(1) series).
    """
    prices = download_prices(
        tickers=tickers, start=start, end=end,
        price_field=price_field, log_prices=log_prices, align="inner"
    )

    if prices.shape[1] < 2:
        raise ValueError("Need at least two tickers after alignment.")

    # Optional pretest: ensure individual series are I(1) (non-stationary in levels)
    keep_cols = list(prices.columns)
    level_stationary_flags = {}
    if pretest_unit_root:
        flags = {}
        for col in prices.columns:
            # ADF on level series; null = unit root. If we REJECT (p<0.05), series is I(0).
            stat, pval, *_ = adfuller(prices[col].values, regression="c", autolag="AIC")
            flags[col] = (pval >= 0.05)  # True means likely I(1); False means I(0)
        level_stationary_flags = {k: (not v) for k, v in flags.items()}  # True if I(0)
        if drop_if_stationary_level:
            keep_cols = [c for c in prices.columns if flags[c]]  # keep only likely I(1)
            prices = prices[keep_cols]
            if len(keep_cols) < 2:
                raise ValueError("After pretesting, fewer than two I(1) series remain.")

    rows = []
    for y_name, x_name in permutations(prices.columns, 2):
        y = prices[y_name]
        x = prices[x_name]

        # Cointegrating regression (step 1)
        alpha, beta, resid = ols_hedge_ratio(y, x, include_const=include_const)

        # Engle–Granger residual ADF (step 2)
        adf_res = adf_on_residuals(
            residuals=resid,
            regression=regression,
            maxlag=maxlag,
            autolag=autolag,
        )

        rows.append({
            "Y": y_name,
            "X": x_name,
            "alpha": alpha,
            "beta": beta,
            "adf_stat": adf_res["adf_stat"],
            "pvalue": adf_res["pvalue"],
            "crit_1pct": adf_res["crit_1pct"],
            "crit_5pct": adf_res["crit_5pct"],
            "crit_10pct": adf_res["crit_10pct"],
            "usedlag": adf_res["usedlag"],
            "nobs": adf_res["nobs"],
            "icbest": adf_res["icbest"],
            "phi_ar1": adf_res["phi_ar1"],
            "half_life_days": adf_res["half_life"],
        })

    result = pd.DataFrame(rows)

    # Sort by ADF statistic (more negative is stronger rejection of unit root) and then p-value
    result = result.sort_values(["adf_stat", "pvalue"], ascending=[True, True]).reset_index(drop=True)

    # Attach stationarity decision columns at common levels
    result["reject_5pct"] = result["adf_stat"] < result["crit_5pct"]
    result["reject_1pct"] = result["adf_stat"] < result["crit_1pct"]

    # Optional meta on pretesting
    if pretest_unit_root:
        result.attrs["level_stationary_flags"] = level_stationary_flags  # {ticker: True if I(0)}

    return result

if __name__ == "__main__":
    # Example usage
    tickers = ["KO", "MCD"]
    df = engle_granger_pairs(
        tickers=tickers,
        start="2018-01-01",
        end=None,
        price_field="Adj Close",
        log_prices=True,
        include_const=True,   # y = alpha + beta x
        regression="c",       # ADF with constant on residuals
        maxlag=None,          # let autolag choose
        autolag="AIC",
        pretest_unit_root=True,
        drop_if_stationary_level=True,
    )

    # Top candidates (most negative ADF)
    pd.set_option("display.width", 160)
    pd.set_option("display.max_columns", 20)
    print(df.head(10))